# 打家劫舍

## 打家劫舍（1）

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

### 示例



<pre><code>输入：[1,2,3,1]
<strong>输出：
</strong>4
<strong>解释：
</strong>偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。</code></pre>

### 状态转移

用dp\[n]表示前n个房屋组成的子序列能偷到的最高金额。

dp\[n] = max(dp\[n-1], dp\[n-2]+nums\[n])

#### 当时卡住的点：纠结n-1有没有偷。其实上述转移方程已经统一这些情况了

dp\[n-1]没加nums\[n]，不代表偷了n-1，若偷了n-1，那么不能偷n，合理；

若没偷n-1,dp\[n-1]退化成dp\[n-2]，那么dp\[n] = dp\[n-2] + nums\[n]。

就已把dp\[n-1]分类成了两种情况。当时总想着怎么用一种统一的方式，没想到分类，于是卡住，分类是有用的方式，在打家劫舍（2）也有体现

## 打家劫舍（2）

这次房屋是环状的，意味着第一个屋子(nums\[0])和最后一个屋子(nums\[n])也是相邻的。

### 思路

其实也是用分类的思想，不用纠结于如何统一去做。

直接分类成不偷nums\[0]和不偷nums\[n]的情况即可覆盖所有情况（其中两者都包含既不偷nums\[0]也不偷nums\[n]的情况，但是无所谓，求得是最大值），两种情况都相当于之前非环状的情况，求解方式相同，最后取最大值即可得答案。

分类的时候按不偷xx分类，而不是按偷xx分类，这样才能包含所有情况。
