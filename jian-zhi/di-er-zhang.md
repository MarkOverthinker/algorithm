# 第二章

## 2.3  数据结构

### 2.3.1  数组

#### 题3.数组中重复的数字

> 题目(1)  长度为n的数组中所有数字都在0\~n-1的范围内。数组中有重复数字，但不知道有几个重复，但不知道重复的数字重复了多少次找出任意一个重复的数字。

排序是很简单的做法，时间 O(nlogn)

很容易想到用哈希表，空间换时间，时间O(n),空间O(n)

进一步优化：可以利用数组本身能做哈希的特性，直接在原数组用hash(i)=i的方式构造哈希，空间优化到O(1)，时间还是O(n),步骤：

遍历数组nums，做如下操作：

1. 如果 nums\[i] == i,则i相当于已放在哈希表中；遍历下一个；否则2
2. 计nums\[i] = m,因为hash(m) = m,那么m应该存在nums\[m],看nums\[m]是否为m，若为m，则说明m为重复数字，否则交换nums\[i]和nums\[m]，相当于在哈希表中添加了(m,m);对新交换过来的nums\[i],重复上述操作。

> 题目(2)  数组长度n+1,数字范围1\~n,现在不能改数组,又想保证空间复杂度低。

如果还想空间复杂度为O(1)，可以二分查找，由于容斥定理如果遍历数组得到数组中1\~m的数的种类数量小于m那么这组数一定有重复的数。可以先用这个方法，先看1\~n/2中有没有重复的数，若有就再找1\~n/4,否则说明在n/2+1 \~ n中，可在这个范围里继续二分查找。时间复杂度O(nlogn).二分logn,遍历数组计数O(n).

#### 题4. 二维数组中查找数字

> 给定二维数组，每列每行都是升序的，找到n是否存在于该数组中。

方法：每次都找可能区域的右上角或者左下角。通过大小关系排除一行/列。

原理：右上角或左下角的数，都是一侧大于它一侧小于他，而其他地方的数都至少有两侧的数都大于它或小于他不能做到一次排除一列。

### 2.3.2 字符串

#### 题5. 替换字符串中的空格

> 把字符串中的空格替换成ASCII码%20.需判断题目要求，如果是在原字符串上构造，需要字符串空间足够并且考虑到替换时可能对原字符串覆盖。如果可以新字符串上构造那倒是挺简单。

最简单粗暴的方式：从前往后遍历，遇到空格就往后移后面的字符串，然后替换入%20，这种方法会涉及多次重复的字符串移动操作，时间复杂度O(n^2)。

改善：如果能知道每个字符应该移动到那里，就可以避免不必要的多次移动。所以可以先遍历一遍字符串，记录有多少个空格，再计算出将全部空格全替换成%20后字符串的长度。之后，从后往前遍历，用两个指针，p1指向原字符串尾，p2指向新字符串尾；当p1遇到非空格字符，将p1字符移到p2，然后p1，p2移动一位。当p1遇到空格，则以p2所指位置为%20末尾将%20移入，之后p1前移一位，p2也移到%前的位置。这样，只需遍历两次字符串即可，时间复杂度O(n)；

> 变式题：两个数组a,b中有排序好的数，数组a有多余充足空间，如何将b中数组全移进a。
>
> 从前往后插入肯定又要涉及多次元素移动。可以采取从后往前归并两个数组的方式，比较两个数组的末尾，将较大的添加到数组a末尾位置。归并一遍就完成了。

在合并两个数组（包括字符串时）可以从后往前复制，减少移动的次数。



### 2.3.5 栈和队列

#### 题9 . 用两个栈实现队列

将两个栈记为stk1, stk2,在添加元素时将元素添加到stk1,在输出元素时，如果stk2中为空，就把stk1中的元素全部输入到stk2中，实现了顺序的倒转，然后从stk2输出。

即：输入由stk1完成，输出由stk2完成，关键的地方在于stk1输入到stk2的时机：在stk2为空的时候才输入到stk2。这样就保证stk2中的元素输出次序一定是先于stk1中的，在stk2中有元素时输入到stk1里也没有影响，等stk2空之后再将stk1输入到stk2，顺序还是对的。

#### 相关题： 用队列实现栈

两个队列q1, q2

入栈时： 输入q1

出栈时： 将q1前n-1个输出到q2，剩下的最后一个就是栈顶。输出之后swap(q1, q2)。

实质上就是用q2暂存前n-1个，剩下的最后那个就是栈顶，因为队列先进先出，所以输出到q2后顺序没什么变化，直接swap回去就可以。

### 2.4.2 查找和排序

> 对公司职员年龄进行排序，年龄范围为固定值0\~99，可以使用O(n)的辅助空间
>
> 那么可以遍历一遍职员年龄数组ages，记录每个年龄出现的次数。之后，从小到大遍历0\~99之间的年龄次数，从前往后对ages，每个年龄出现多少次就设置ages多少个元素为该年龄。设置完后排序就已完成，时间复杂度O(n)。因为年龄值为0\~99，所以辅助数组大小只需要为100即可，满足要求。

注：上述方法其实就是计数排序。

#### 题11.旋转数组的最小数字

> 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
>
> 给你一个可能存在 **重复** 元素值的数组 `numbers` ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的**最小元素**。例如，数组 `[3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一次旋转，该数组的最小值为 1。 &#x20;
>
> 注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

* 只与最右比较时为了统一几种情况。剑指中使用了与两遍都比较然后分类的方式，某些情况下效率更高。
* 找到通过与最右边的数比较，得到mid位于前一个升序列还是后一个升序列。
* 存在一整个数组都为升序列的情况，所以选择的是与最右边比较，最后不断缩到第一个元素。（相当于只有后一个升序列）。如果用只与最左比较的方法，那就相当于只有前一个升序列，这种情况下无法正确处理。所以还是要用只与最左比较。
* mid与最右相同时，存在首尾也相同和首>尾的情况，前者无法确定mid位于前一个升序列还是后一个升序列，此时只能顺序查找；后者确定Mid位于第二个升序列，收缩右边界即可；具体实现的时候，可分类讨论，也可如下面代码一样，使用r--进行统一两种情况。但是使用r--统一时在面临后一种情况的时候，效率可能不如分类讨论。如旋转数组：3451222222222222。（会用很多次r--，而分类讨论的话r可以直接快速跳转）。

代码：

````
// Some code
```cpp
class Solution {
public:
    int minArray(vector<int>& numbers) {
        int l = 0, r = numbers.size()-1;
        while (l < r) {
            int m = l + (r - l)/2;
            if (numbers[m] < numbers[r]) {
            // 最终需要的结果是右边的数，所以r=m，不减一，防止失去这个数
                r = m;
            } else if (numbers[m] > numbers[r]) {
            // 最终结果要的是右边的数，左边数可以不要，所以是m+1。这样while循环才能结束
                l = m + 1;
            } else {
            // 统一首中尾相等和中尾相等的情况。
                r--;
            }
        }
        return numbers[l];
    }
};
```
````

### 2.4.3 回溯

> 题12. 给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。
>
> 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

![](<../.gitbook/assets/image (4).png>)



使用回溯进行查询是否存在

注意不能重复使用字母，所以要用visited数组保存哪些元素被使用过。

````
```cpp
class Solution {
public:

    // visited传引用，每次修改后，在最后在将其复原。这样可以省去值传递的空间占用。
    bool haspath(vector<vector<char>>& board, string &word, int i, int j, vector<vector<bool>> &visited, int k) {
        // 被访问过则return false。也可以在下面选择不访问被访问的元素
        //if (visited[i][j]) {
        //    return false;
        // }
        if (board[i][j] != word[k]) {
            return false;
        } else if (k == word.length() - 1) {
            return true;
        }
        visited[i][j] = true;
        // 四个方向
        vector<pair<int, int>> dir{make_pair(0, -1), make_pair(0, 1), make_pair(-1, 0), make_pair(1, 0)};
        bool flag = false;
        for (const auto& d : dir) {
            int newi = i + d.first;
            int newj = j + d.second;
            if (newi >= 0 && newi < board.size() && newj >= 0 && newj < board[0].size() && !visited[newi][newj]) {
                flag = haspath(board, word, newi, newj, visited, k+1);
                if (flag) {
                    return true;
                }
            }
        }
        visited[i][j] = false;
        return false;
    }

    bool exist(vector<vector<char>>& board, string word) {
        int w = board[0].size();
        int h = board.size();
        vector<vector<bool>> visited(h, vector<bool>(w, false));
        for (int i = 0; i < h; ++i) {
            for (int j = 0; j < w; ++j) {
                bool flag = haspath(board, word, i, j, visited, 0);
                if (flag) {
                    return true;
                }
            }
        }
        return false;
    }
};
```
````

### 2.4.4 动态规划和贪心

> 题14. 剪绳子
>
> 给你一根长度为 `n` 的绳子，请把绳子剪成整数长度的 `m` 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 `k[0],k[1]...k[m-1]` 。请问 `k[0]*k[1]*...*k[m-1]` 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

动态规划方式：

![](../.gitbook/assets/image.png)

```
class Solution {
public:
    int cuttingRope(int n) {
        vector <int> dp(n + 1);
        for (int i = 2; i <= n; i++) {
            int curMax = 0;
            for (int j = 1; j < i; j++) {
                curMax = max(curMax, max(j * (i - j), j * dp[i - j]));
            }
            dp[i] = curMax;
        }
        return dp[n];
    }
};

```

贪心算法方式：

当n大于等于5的时候剪无脑剪3，等于4就剪成两个2.

证明：

![](../.gitbook/assets/IMG\_20221215\_170156.jpg)

```
class Solution {
public:
    int cuttingRope(int n) {
        if (n <= 3) {
            return n - 1;
        }
        int quotient = n / 3;
        int remainder = n % 3;
        0, 1, 2三种情况
        if (remainder == 0) {
            return (int)pow(3, quotient);
        } else if (remainder == 1) {
            return (int)pow(3, quotient - 1) * 4;
        } else {
            return (int)pow(3, quotient) * 2;
        }
    }
};
```

### 2.4.5 位运算

> 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 [汉明重量](http://en.wikipedia.org/wiki/Hamming\_weight)).）。

````
```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int cnt = 0;
        while (n) {
            // 消除最右边的1，每消除一次，计数加一
            n = n & (n-1);
            cnt++;
        }
        return cnt;
    }
};
```
````

* 可用n & (n-1) ==0判断是否为2的整数次方。
* 计算两个数有多少位相同，可异或两个数，再计算结果中有多少位1。
